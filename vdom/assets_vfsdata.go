// Code generated by vfsgen; DO NOT EDIT.

package vdom

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	pathpkg "path"
	"time"
)

// assets statically implements the virtual filesystem provided to vfsgen.
var assets = func() http.FileSystem {
	fs := vfsgen۰FS{
		"/": &vfsgen۰DirInfo{
			name:    "/",
			modTime: time.Date(2019, 4, 12, 22, 14, 2, 672330900, time.UTC),
		},
		"/index.html": &vfsgen۰CompressedFileInfo{
			name:             "index.html",
			modTime:          time.Date(2019, 4, 25, 5, 5, 22, 962534600, time.UTC),
			uncompressedSize: 2914,

			compressedContent: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xcc\x56\x5f\x6f\xdb\x36\x10\x7f\xcf\xa7\xb8\xe9\xa1\x90\x51\x43\x72\xd2\x0d\x28\x6c\xab\xc0\x90\x16\xeb\xb6\x36\x1b\xe6\x6c\x7d\x28\xf2\xc0\x50\x67\x99\x0b\x4d\x0a\xe4\x59\xae\x51\xf8\xbb\x0f\xa4\x28\x9b\x92\x9d\x65\x79\x18\x50\x3f\x58\xe4\xf1\xfe\xfe\xee\x78\xbc\xf9\x8a\xd6\xf2\xcd\x05\xc0\x7c\x85\xac\x74\x0b\x80\xb9\xe5\x46\xd4\x04\xb4\xab\xb1\x48\x08\xbf\x50\xfe\x37\x6b\x58\x4b\x4d\x5a\x1e\x80\x3c\x87\xc5\x5f\x3f\x81\x62\x6b\xb4\x35\xe3\x08\x28\x71\x8d\x8a\x40\x0a\x4b\x90\x2a\xc4\x12\x18\xdc\x23\x11\x1a\xb0\x5a\x6e\x48\x68\x35\x0a\xc2\xb6\xa9\xde\xb5\xec\x16\x0a\xf8\x9a\xd8\xa6\x4a\xa6\x97\x63\x48\xc2\xc7\x20\xa7\x76\xc5\x85\xe1\x12\xdb\x35\x4a\x29\x6a\x1b\x36\x52\xa8\xb0\xaa\xb5\xdc\xf5\x77\x95\x56\xc9\xf4\x72\x3f\xbb\x08\xe6\xb8\x56\x96\xe0\x5a\x0a\xfe\x00\x05\x4c\xc6\x81\x0c\xf0\x51\x6f\x2c\xbe\xd5\x5b\x05\x05\x5c\x0e\xc8\x7f\xd6\x50\xc0\xd5\x91\xf8\x2b\xee\x02\xe7\xab\x1e\xd1\xf3\x7d\x7f\x24\x5d\xaf\x98\xaa\x10\x0a\xf8\xe1\x60\xbf\x61\x0e\x02\xfe\x80\x74\x20\x2d\x37\x8a\x3b\x44\xc0\x60\x25\x2c\xa1\x79\xd7\xa0\xa2\xf7\x4c\x95\x12\x4d\xaa\x74\x89\x63\x9f\x80\x31\x88\x72\x04\x5f\x0f\xda\xed\x56\x10\x5f\x41\xea\xce\x62\x3a\x00\x67\x16\xdb\x18\xa7\x11\x15\xc0\xe9\xca\x58\x59\x7a\x03\x1f\x9c\x2d\x85\x26\x4d\xb8\xe3\x4c\xc6\x07\x47\x52\x6c\xa8\xaf\xd0\xfd\x24\x12\x94\x7a\xed\x65\x5d\xa6\x06\xc7\x00\xb7\xbb\x1a\xa7\xad\xa7\x27\x67\x21\xc5\x3f\x97\x53\x10\xe5\xe9\xf1\x5b\x46\x6c\x0a\xad\x23\x58\x26\x83\xf3\xfd\x6c\x40\x68\x01\xcc\x2c\xaa\x32\xfd\x65\xf1\xdb\x4d\x66\xc9\x08\x55\x89\xe5\x2e\xed\x3c\x1c\x8d\xfa\x42\xfb\xc1\xfe\xde\x20\x7b\x98\x9d\x60\xe6\x13\xf6\xdf\x40\xf3\xac\xdf\x00\x6a\xd8\x50\x46\xcc\x54\x48\x59\xc3\xe4\x06\x9f\x02\xcf\xdd\x00\x2d\x31\x93\xba\x3a\xa2\xf5\xff\x23\xbc\xbf\xe8\xbe\xc3\xb2\xe7\x06\x19\x61\x88\xf5\x0f\xe4\x1b\x63\x45\x83\x69\x68\x22\x31\xa4\x0e\x4c\x97\x0e\x28\x40\x6d\xa4\x3c\x2a\x17\x4b\xe8\xf8\xb3\x1b\xb6\x46\x10\x2a\x6e\x2c\xc3\xb4\x04\x1d\xa5\xe6\x1b\x2f\xd2\xf3\xe0\x66\x91\x26\x2b\xa2\x7a\x9a\xe7\xdb\xed\x36\xdb\xbe\xca\xb4\xa9\xf2\xab\xc9\x64\x92\xbb\xde\x34\x86\xd8\xd0\xe8\x34\x40\x00\x94\x16\x9f\x63\x31\x7d\x54\xe3\x61\xb9\xd4\x06\x52\xd7\x3b\x54\x88\xae\x13\xf9\x91\xc8\x0c\xe2\xf3\x05\x6b\x91\xdc\x91\xb8\xdf\x10\xa6\x4e\x68\xdc\x17\xf9\xec\x68\x77\x4f\x18\x13\xae\x45\xce\x40\xc0\xfc\x20\x7c\xbd\x12\xb2\x34\xa8\x32\x89\xaa\xa2\xd5\x0c\xc4\xcb\x97\x7d\xf3\x71\x2e\x3a\xee\xcf\xe2\x2e\x73\x85\x0e\x45\x01\x57\xe7\xb2\x91\x09\xa5\xd0\xdc\xe2\x17\x77\x49\xce\x49\xb7\x4e\x27\x8e\x23\xb9\x8b\x0b\x6d\x7f\x0e\x6e\xee\x24\xa1\x78\xa2\xb4\x62\x03\x83\xe2\x6d\x2f\x7d\x5d\xa3\x2a\x3d\x53\xea\x35\xf6\x98\xf6\xcf\x85\x2e\x6e\xeb\xf6\x71\xfc\xce\xbe\x02\x27\xce\xf5\xbb\xc1\x59\x13\x1d\xe8\xe7\x59\x03\xa0\xa2\x4c\xee\xa2\xf3\xf3\x05\x61\x90\x36\x46\x79\xbb\xb3\x47\xaf\x31\xab\x6b\xb9\xfb\x9d\x11\x5f\xa5\xb5\xfb\x8f\xa3\xea\xf2\x71\xa8\xff\x7b\x5d\xee\xb2\xa5\x30\x96\x42\x72\x3c\xca\xfd\x0b\xdd\x0a\xbd\x78\x01\xdf\x85\xa5\x50\x96\x98\xe2\xa8\x97\xf0\xfe\xf6\xe3\x87\x85\x9f\x42\x82\xfc\xa8\x0f\x62\xdf\x90\xc1\xb5\x6e\xf0\x7c\x22\xa3\x30\xc3\x25\x7d\xa4\x68\x7c\x50\x59\x67\xee\xa8\xa0\x6f\x2a\xae\x19\xa7\x6f\x74\x02\xd8\xd6\xcd\x39\x42\x09\xfa\xb4\x48\x47\xa7\x43\x40\x77\x12\x3f\xf4\xbe\x19\xbb\xa6\x87\x5b\xf8\x84\xf7\x0b\xbf\x4f\x93\xad\x9d\xe6\xb9\xd4\x9c\xc9\x95\xb6\x34\x7d\x3d\x79\x3d\xc9\xb9\x14\xa8\x28\x89\xfc\x0b\xad\x5c\x2b\x5d\xa3\x1b\x59\x0e\xef\xd5\x60\x66\x88\x9e\x85\x24\x58\x74\x12\xb1\xaa\xfd\x19\xad\x6b\xb4\x96\xf9\x21\xe7\xf8\x10\xf6\x35\x7b\xe0\xa0\x00\xff\x8e\xd4\xcc\x58\x4c\x31\x2b\x19\xb1\xde\x75\x8a\xed\xb7\xf5\x13\x9f\x9e\x14\xd7\xbf\x3b\xc5\xa5\xb6\xf8\xbc\x58\xbd\xc8\x23\xc1\x86\xfa\xef\xe6\xb6\x2e\xa1\xee\x7f\x9e\xb7\xc3\xb0\x1f\x9c\xf3\x6e\x72\x9e\xbb\x5a\x78\x33\xcf\xfd\xe7\x62\x9e\xb7\xa3\xf5\x3f\x01\x00\x00\xff\xff\x57\x40\xfe\x94\x62\x0b\x00\x00"),
		},
	}
	fs["/"].(*vfsgen۰DirInfo).entries = []os.FileInfo{
		fs["/index.html"].(os.FileInfo),
	}

	return fs
}()

type vfsgen۰FS map[string]interface{}

func (fs vfsgen۰FS) Open(path string) (http.File, error) {
	path = pathpkg.Clean("/" + path)
	f, ok := fs[path]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: path, Err: os.ErrNotExist}
	}

	switch f := f.(type) {
	case *vfsgen۰CompressedFileInfo:
		gr, err := gzip.NewReader(bytes.NewReader(f.compressedContent))
		if err != nil {
			// This should never happen because we generate the gzip bytes such that they are always valid.
			panic("unexpected error reading own gzip compressed bytes: " + err.Error())
		}
		return &vfsgen۰CompressedFile{
			vfsgen۰CompressedFileInfo: f,
			gr:                        gr,
		}, nil
	case *vfsgen۰DirInfo:
		return &vfsgen۰Dir{
			vfsgen۰DirInfo: f,
		}, nil
	default:
		// This should never happen because we generate only the above types.
		panic(fmt.Sprintf("unexpected type %T", f))
	}
}

// vfsgen۰CompressedFileInfo is a static definition of a gzip compressed file.
type vfsgen۰CompressedFileInfo struct {
	name              string
	modTime           time.Time
	compressedContent []byte
	uncompressedSize  int64
}

func (f *vfsgen۰CompressedFileInfo) Readdir(count int) ([]os.FileInfo, error) {
	return nil, fmt.Errorf("cannot Readdir from file %s", f.name)
}
func (f *vfsgen۰CompressedFileInfo) Stat() (os.FileInfo, error) { return f, nil }

func (f *vfsgen۰CompressedFileInfo) GzipBytes() []byte {
	return f.compressedContent
}

func (f *vfsgen۰CompressedFileInfo) Name() string       { return f.name }
func (f *vfsgen۰CompressedFileInfo) Size() int64        { return f.uncompressedSize }
func (f *vfsgen۰CompressedFileInfo) Mode() os.FileMode  { return 0444 }
func (f *vfsgen۰CompressedFileInfo) ModTime() time.Time { return f.modTime }
func (f *vfsgen۰CompressedFileInfo) IsDir() bool        { return false }
func (f *vfsgen۰CompressedFileInfo) Sys() interface{}   { return nil }

// vfsgen۰CompressedFile is an opened compressedFile instance.
type vfsgen۰CompressedFile struct {
	*vfsgen۰CompressedFileInfo
	gr      *gzip.Reader
	grPos   int64 // Actual gr uncompressed position.
	seekPos int64 // Seek uncompressed position.
}

func (f *vfsgen۰CompressedFile) Read(p []byte) (n int, err error) {
	if f.grPos > f.seekPos {
		// Rewind to beginning.
		err = f.gr.Reset(bytes.NewReader(f.compressedContent))
		if err != nil {
			return 0, err
		}
		f.grPos = 0
	}
	if f.grPos < f.seekPos {
		// Fast-forward.
		_, err = io.CopyN(ioutil.Discard, f.gr, f.seekPos-f.grPos)
		if err != nil {
			return 0, err
		}
		f.grPos = f.seekPos
	}
	n, err = f.gr.Read(p)
	f.grPos += int64(n)
	f.seekPos = f.grPos
	return n, err
}
func (f *vfsgen۰CompressedFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekStart:
		f.seekPos = 0 + offset
	case io.SeekCurrent:
		f.seekPos += offset
	case io.SeekEnd:
		f.seekPos = f.uncompressedSize + offset
	default:
		panic(fmt.Errorf("invalid whence value: %v", whence))
	}
	return f.seekPos, nil
}
func (f *vfsgen۰CompressedFile) Close() error {
	return f.gr.Close()
}

// vfsgen۰DirInfo is a static definition of a directory.
type vfsgen۰DirInfo struct {
	name    string
	modTime time.Time
	entries []os.FileInfo
}

func (d *vfsgen۰DirInfo) Read([]byte) (int, error) {
	return 0, fmt.Errorf("cannot Read from directory %s", d.name)
}
func (d *vfsgen۰DirInfo) Close() error               { return nil }
func (d *vfsgen۰DirInfo) Stat() (os.FileInfo, error) { return d, nil }

func (d *vfsgen۰DirInfo) Name() string       { return d.name }
func (d *vfsgen۰DirInfo) Size() int64        { return 0 }
func (d *vfsgen۰DirInfo) Mode() os.FileMode  { return 0755 | os.ModeDir }
func (d *vfsgen۰DirInfo) ModTime() time.Time { return d.modTime }
func (d *vfsgen۰DirInfo) IsDir() bool        { return true }
func (d *vfsgen۰DirInfo) Sys() interface{}   { return nil }

// vfsgen۰Dir is an opened dir instance.
type vfsgen۰Dir struct {
	*vfsgen۰DirInfo
	pos int // Position within entries for Seek and Readdir.
}

func (d *vfsgen۰Dir) Seek(offset int64, whence int) (int64, error) {
	if offset == 0 && whence == io.SeekStart {
		d.pos = 0
		return 0, nil
	}
	return 0, fmt.Errorf("unsupported Seek in directory %s", d.name)
}

func (d *vfsgen۰Dir) Readdir(count int) ([]os.FileInfo, error) {
	if d.pos >= len(d.entries) && count > 0 {
		return nil, io.EOF
	}
	if count <= 0 || count > len(d.entries)-d.pos {
		count = len(d.entries) - d.pos
	}
	e := d.entries[d.pos : d.pos+count]
	d.pos += count
	return e, nil
}
